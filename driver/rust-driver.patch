diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 433aa4197785..aa0f84f4fd20 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -5,8 +5,15 @@
 
 menu "Misc devices"
 
+config LKP_ENC
+	tristate "LKP Encryption"
+	help
+		Enable or disable the driver for LKP encryption virtual device
+
+		If unsure, say N.
+
 config SENSORS_LIS3LV02D
-	tristate
+	tristate	
 	depends on INPUT
 
 config AD525X_DPOT
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 56de43943cd5..83facbab7549 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -3,6 +3,7 @@
 # Makefile for misc devices that really don't fit anywhere else.
 #
 
+obj-$(CONFIG_LKP_ENC)				+= lkp_enc.o
 obj-$(CONFIG_IBM_ASM)		+= ibmasm/
 obj-$(CONFIG_IBMVMC)		+= ibmvmc.o
 obj-$(CONFIG_AD525X_DPOT)	+= ad525x_dpot.o
diff --git a/drivers/misc/lkp_enc.rs b/drivers/misc/lkp_enc.rs
new file mode 100644
index 000000000000..41908afadbcc
--- /dev/null
+++ b/drivers/misc/lkp_enc.rs
@@ -0,0 +1,214 @@
+//! Rust HW9 driver module
+//!
+//! This module is a Rust implementation of the HW9 driver module written in C.
+
+use core::result::Result::Ok;
+use kernel::bindings;
+use kernel::chrdev;
+use kernel::file;
+use kernel::sync::Mutex;
+use kernel::user_ptr::UserSlicePtr;
+use kernel::{
+    ioctl::{_IOR, _IOW},
+    prelude::*,
+    Module,
+};
+
+module! {
+    type: LkpEnc,
+    name: "lkp_enc",
+    author: "Riccardo Strina",
+    description: "HW9... but in Rust!",
+    license: "GPL",
+}
+
+const LKP_ENC_WRITE_SEED: u32 = _IOW::<u32>('q' as u32, 1);
+const LKP_ENC_WRITE_STRING: u32 = _IOW::<&str>('q' as u32, 2);
+const LKP_ENC_READ_STRING: u32 = _IOR::<&str>('q' as u32, 3);
+
+const DEVICE_BASE_PHYS_ADDR: u64 = 0xfebd1000;
+const SIZE: u64 = 4096;
+
+static DEVMEM: Mutex<usize> = unsafe { Mutex::new(0) };
+
+struct LkpEnc {
+    _dev: Pin<Box<chrdev::Registration<1>>>,
+    // consider to switch to miscdev to remove DEVMEM and having it as a field in the struct
+    // for more info look at the examples in the rust samples directory
+    // _dev: Pin<Box<miscdev::Registration<LkpEnc>>>,
+}
+
+fn read_device(ptr: usize) -> Vec<u8> {
+    let mut ret: Vec<u8> = Vec::new();
+    let bound = (SIZE - 5) as usize;
+
+    for i in 0..bound {
+        let c: u8 = unsafe { bindings::ioread8((ptr + 4 + i) as _) as u8 };
+        let _ = ret.try_push(c);
+
+        if c == b'\0' {
+            break;
+        }
+    }
+
+    ret
+}
+
+fn write_device(ptr: usize, s: &[u8]) {
+    // avoid to write in memory otherwise not handled by the device
+    let device_bound:usize = (SIZE - 5) as usize;
+
+    for (i, c) in s.iter().enumerate() {
+        unsafe { bindings::iowrite8(*c, (ptr + 4 + i) as _) };
+
+        if *c == b'\0' {
+            break;
+        }
+
+        if i == device_bound {
+            // if the device bound is reached write a null terminator and break
+            unsafe { bindings::iowrite8(b'\0', (ptr + 4 + i) as _) };
+            break;
+        }
+    }
+}
+
+#[vtable]
+impl file::Operations for LkpEnc {
+    fn open(_context: &Self::OpenData, _file: &file::File) -> Result<Self::Data> {
+        Ok(())
+    }
+
+    fn write(
+        _data: Self::Data,
+        _file: &file::File,
+        reader: &mut impl kernel::io_buffer::IoBufferReader,
+        _offset: u64,
+    ) -> Result<usize> {
+        match reader.read_all() {
+            Ok(mut s) => {
+                // null terminate the string before writing it to the device
+                // echo doesn't provide a null terminated string
+                let _ = s.try_push(b'\0');
+                write_device(*DEVMEM.lock(), &s);
+
+                // echo will expect a different number of bytes written, adding 0 to the end
+                // is not expected and will return an error
+                Ok(s.len() - 1)
+            }
+            Err(e) => {
+                pr_info!("Error reading string: {:?}", e);
+
+                Ok(0)
+            }
+        }
+    }
+
+    fn read(
+        _data: Self::Data,
+        _file: &file::File,
+        writer: &mut impl kernel::io_buffer::IoBufferWriter,
+        offset: u64,
+    ) -> Result<usize> {
+        // If the offset is 0, it means we're starting to read from the beginning.
+        // If the offset is greater than 0, in this simple case, we assume the message was already read,
+        // and thus we return Ok(0) to indicate no more data is to be read.
+        if offset == 0 {
+            let message = read_device(*DEVMEM.lock());
+            let _ = writer.write_slice(&message);
+
+            Ok(message.len())
+        } else {
+            // No more data to read, indicate this by returning 0 bytes read.
+            Ok(0)
+        }
+    }
+
+    fn ioctl(
+        _data: <Self::Data as kernel::ForeignOwnable>::Borrowed<'_>,
+        _file: &file::File,
+        cmd: &mut file::IoctlCommand,
+    ) -> Result<i32> {
+        let io_number = cmd.raw().0;
+        let ptr = cmd.raw().1;
+        let user_slice = unsafe { UserSlicePtr::new(ptr as _, SIZE as _) };
+
+        match io_number {
+            LKP_ENC_WRITE_SEED => {
+                let seed: u32 = match user_slice.read_all() {
+                    Ok(s) => {
+                        if !s.is_empty() {
+                            s[0] as u32
+                        } else {
+                            0
+                        }
+                    }
+                    Err(e) => {
+                        pr_info!("Error reading seed: {:?}", e);
+
+                        0
+                    }
+                };
+
+                unsafe {
+                    bindings::iowrite32(seed, *DEVMEM.lock() as _);
+                }
+            }
+            LKP_ENC_READ_STRING => {
+                let ret = read_device(*DEVMEM.lock());
+
+                let _ = user_slice.write_all(&ret);
+            }
+            LKP_ENC_WRITE_STRING => match user_slice.read_all() {
+                Ok(s) => {
+                    write_device(*DEVMEM.lock(), &s);
+                }
+                Err(e) => {
+                    pr_info!("Error reading string: {:?}", e);
+                    return Ok(-1);
+                }
+            },
+            _ => {
+                pr_info!("Unknown IOCTL command");
+                return Ok(-1);
+            }
+        }
+
+        Ok(0)
+    }
+}
+
+impl Module for LkpEnc {
+    fn init(name: &'static CStr, module: &'static ThisModule) -> Result<Self> {
+        pr_info!("{} module init", name);
+
+        let addr = unsafe { bindings::ioremap(DEVICE_BASE_PHYS_ADDR, SIZE) };
+
+        // devmem know contains the address mapped in the CPU of the device
+
+        let mut ptr = DEVMEM.lock();
+        *ptr = if addr.is_null() {
+            Err(ENOMEM)
+        } else {
+            // INVARIANT: `addr` is non-null and was returned by `ioremap`, so it is valid. It is
+            // also 8-byte aligned because we checked it above.
+            Ok(addr as usize)
+        }?;
+
+        let mut chardev_reg = chrdev::Registration::new_pinned(name, 0, module)?;
+        chardev_reg.as_mut().register::<LkpEnc>()?;
+
+        pr_info!("LKP_ENC_WRITE_SEED: {:?}", LKP_ENC_WRITE_SEED);
+        pr_info!("LKP_ENC_READ_STRING: {:?}", LKP_ENC_READ_STRING);
+        pr_info!("LKP_ENC_WRITE_STRING: {:?}", LKP_ENC_WRITE_STRING);
+
+        Ok(LkpEnc { _dev: chardev_reg })
+    }
+}
+
+impl Drop for LkpEnc {
+    fn drop(&mut self) {
+        pr_info!("lkp_enc module exit\n");
+        unsafe { bindings::iounmap(*DEVMEM.lock() as _) };
+    }
+}
diff --git a/init/main.c b/init/main.c
index bb87b789c543..80ab2738491f 100644
--- a/init/main.c
+++ b/init/main.c
@@ -1516,7 +1516,10 @@ void __weak free_initmem(void)
 
 static int __ref kernel_init(void *unused)
 {
-	int ret;
+	int ret, i;
+	void* devmem;
+	char orig[256] = "Hello World, this is a test string for LKP-ENC", encrypted[256];
+	unsigned int data;
 
 	/*
 	 * Wait until kthreadd is all set-up.
@@ -1548,6 +1551,49 @@ static int __ref kernel_init(void *unused)
 
 	do_sysctl_args();
 
+	printk("------------------------------------------------------------------\n");
+	printk("BEGIN LKP-ENC TEST\n");
+	printk("------------------------------------------------------------------\n");
+
+	devmem = ioremap(0xfebd1000, 4096);
+
+	if(devmem) {
+		printk("Address in memory of the device %p\n"
+			   "Another way to print the same 0x%lx\n"
+			   "Another one %lu\n", devmem, devmem, devmem);
+		/**
+		 * Set the seed to the rng device
+		*/
+		iowrite32(1, devmem);
+
+		i = 0;
+		while(orig[i] != '\0') {
+			iowrite8(orig[i], devmem + 4 + i);
+			i++;
+		}
+        iowrite8('\0', devmem + 4 + i);
+
+		data = ioread32(devmem);
+		printk("encryption key returned from ioread32 as int: %u", data);
+
+		i = 0;
+		do{
+			encrypted[i] = ioread8(devmem + 4 + i);
+		} while(i < 255 && encrypted[i++] != '\0');
+		encrypted[i] = '\0';
+		
+		printk("original string : %s\n", orig);
+		printk("encrypted string: %s\n", encrypted);
+		
+		iounmap(devmem);
+	} else {
+		printk("ERROR: cannot map device registers\n");
+	}
+
+	printk("------------------------------------------------------------------\n");
+	printk("END LKP-ENC TEST\n");
+	printk("------------------------------------------------------------------\n");
+	
 	if (ramdisk_execute_command) {
 		ret = run_init_process(ramdisk_execute_command);
 		if (!ret)
diff --git a/rust/kernel/io_mem.rs b/rust/kernel/io_mem.rs
index ff6886a9e3b7..de2d1817acc6 100644
--- a/rust/kernel/io_mem.rs
+++ b/rust/kernel/io_mem.rs
@@ -16,6 +16,7 @@ pub struct Resource {
 }
 
 impl Resource {
+    /// Creates a new Resource instance.
     pub(crate) fn new(
         start: bindings::resource_size_t,
         end: bindings::resource_size_t,
diff --git a/rust/kernel/ioctl.rs b/rust/kernel/ioctl.rs
new file mode 100644
index 000000000000..5fab8fbd7329
--- /dev/null
+++ b/rust/kernel/ioctl.rs
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: GPL-2.0
+
+//! ioctl() number definitions
+//!
+//! C header: [`include/asm-generic/ioctl.h`](../../../../include/asm-generic/ioctl.h)
+
+#![allow(non_snake_case)]
+
+use crate::build_assert;
+
+/// Build an ioctl number, analogous to the C macro of the same name.
+#[inline(always)]
+const fn _IOC(dir: u32, ty: u32, nr: u32, size: usize) -> u32 {
+    build_assert!(dir <= bindings::_IOC_DIRMASK);
+    build_assert!(ty <= bindings::_IOC_TYPEMASK);
+    build_assert!(nr <= bindings::_IOC_NRMASK);
+    build_assert!(size <= (bindings::_IOC_SIZEMASK as usize));
+
+    (dir << bindings::_IOC_DIRSHIFT)
+        | (ty << bindings::_IOC_TYPESHIFT)
+        | (nr << bindings::_IOC_NRSHIFT)
+        | ((size as u32) << bindings::_IOC_SIZESHIFT)
+}
+
+/// Build an ioctl number for an argumentless ioctl.
+#[inline(always)]
+pub const fn _IO(ty: u32, nr: u32) -> u32 {
+    _IOC(bindings::_IOC_NONE, ty, nr, 0)
+}
+
+/// Build an ioctl number for an read-only ioctl.
+#[inline(always)]
+pub const fn _IOR<T>(ty: u32, nr: u32) -> u32 {
+    _IOC(bindings::_IOC_READ, ty, nr, core::mem::size_of::<T>())
+}
+
+/// Build an ioctl number for an write-only ioctl.
+#[inline(always)]
+pub const fn _IOW<T>(ty: u32, nr: u32) -> u32 {
+    _IOC(bindings::_IOC_WRITE, ty, nr, core::mem::size_of::<T>())
+}
+
+/// Build an ioctl number for a read-write ioctl.
+#[inline(always)]
+pub const fn _IOWR<T>(ty: u32, nr: u32) -> u32 {
+    _IOC(bindings::_IOC_READ | bindings::_IOC_WRITE, ty, nr, core::mem::size_of::<T>())
+}
+
+/// Get the ioctl direction from an ioctl number.
+pub const fn _IOC_DIR(nr: u32) -> u32 {
+    (nr >> bindings::_IOC_DIRSHIFT) & bindings::_IOC_DIRMASK
+}
+
+/// Get the ioctl type from an ioctl number.
+pub const fn _IOC_TYPE(nr: u32) -> u32 {
+    (nr >> bindings::_IOC_TYPESHIFT) & bindings::_IOC_TYPEMASK
+}
+
+/// Get the ioctl number from an ioctl number.
+pub const fn _IOC_NR(nr: u32) -> u32 {
+    (nr >> bindings::_IOC_NRSHIFT) & bindings::_IOC_NRMASK
+}
+
+/// Get the ioctl size from an ioctl number.
+pub const fn _IOC_SIZE(nr: u32) -> usize {
+    ((nr >> bindings::_IOC_SIZESHIFT) & bindings::_IOC_SIZEMASK) as usize
+}
diff --git a/rust/kernel/lib.rs b/rust/kernel/lib.rs
index c20b37e88ab2..607cc6833fe1 100644
--- a/rust/kernel/lib.rs
+++ b/rust/kernel/lib.rs
@@ -36,6 +36,7 @@ compile_error!("Missing kernel configuration for conditional compilation");
 mod allocator;
 mod build_assert;
 pub mod error;
+pub mod ioctl;
 pub mod prelude;
 pub mod print;
 mod static_assert;
@@ -44,7 +45,6 @@ pub mod std_vendor;
 pub mod str;
 pub mod sync;
 pub mod types;
-
 #[doc(hidden)]
 pub use bindings;
 pub use macros;
